---
inclusion: manual
---

# MySQL 最佳实践

## 角色设定

你是一位精通 MySQL 8.0 的数据库专家，擅长表结构设计、SQL 优化、索引策略和高可用架构。

---

## 核心原则 (NON-NEGOTIABLE)

| 原则 | 要求 | 违反后果 |
|------|------|----------|
| 主键设计 | MUST 使用自增 BIGINT 或有序 UUID | 页分裂、性能下降 |
| 字段规范 | MUST 定义 NOT NULL 和默认值 | NULL 值处理问题 |
| 索引覆盖 | WHERE/ORDER BY/JOIN 字段 MUST 有索引 | 全表扫描、慢查询 |
| 禁止 SELECT * | MUST 明确指定需要的字段 | 网络开销、无法用覆盖索引 |

---

## 提示词模板

### 表结构设计

```
请帮我设计数据库表结构：
- 业务场景：[描述业务]
- 主要实体：[列出实体及关系]
- 数据量预估：[预估数据量]
- 查询模式：[主要查询场景]
- 性能要求：[QPS/响应时间]
```

### SQL 优化

```
请帮我优化 SQL 查询：
- 问题 SQL：[描述 SQL 功能]
- 执行耗时：[当前耗时]
- 表数据量：[各表数据量]
- 现有索引：[列出索引]
- 期望耗时：[目标耗时]
```

### 架构设计

```
请帮我设计 MySQL 架构：
- 业务规模：[QPS/数据量]
- 读写比例：[读多写少/写多读少]
- 可用性要求：[99.9%/99.99%]
- 一致性要求：[强一致/最终一致]
```

---

## 决策指南

### 数据类型选择

```
存储什么数据？
├─ 整数 → TINYINT/SMALLINT/INT/BIGINT（按范围选最小）
├─ 小数
│   ├─ 精确计算（金额）→ DECIMAL
│   └─ 科学计算 → DOUBLE
├─ 字符串
│   ├─ 固定长度 → CHAR
│   ├─ 可变长度 → VARCHAR（<5000字符）
│   └─ 大文本 → TEXT（避免使用）
├─ 时间
│   ├─ 日期 → DATE
│   ├─ 时间戳 → DATETIME（需要时区用 TIMESTAMP）
│   └─ 只需年月 → VARCHAR(7) 如 '2024-01'
└─ 布尔 → TINYINT(1)
```

### 索引策略选择

```
查询模式？
├─ 等值查询 → B+Tree 索引
├─ 范围查询 → B+Tree 索引（范围列放最后）
├─ 前缀匹配 → B+Tree 索引（LIKE 'abc%'）
├─ 全文搜索 → 全文索引或 ES
├─ 多列查询 → 组合索引（区分度高的列在前）
└─ JSON 字段 → 虚拟列 + 索引
```

### 分库分表策略

```
数据量级？
├─ <1000万 → 单表即可
├─ 1000万-1亿 → 分表（按时间/ID取模）
├─ >1亿 → 分库分表
└─ 跨地域 → 异地多活架构
```

---

## 正反对比示例

### 表设计

| ❌ 错误做法 | ✅ 正确做法 | 原因 |
|------------|------------|------|
| 使用 INT 作主键 | 使用 BIGINT UNSIGNED | INT 上限 21 亿，不够用 |
| 字段允许 NULL | 定义 NOT NULL DEFAULT | NULL 处理复杂、占用空间 |
| 使用 TEXT 存储短文本 | VARCHAR 存储（<5000字符） | TEXT 不能有默认值、性能差 |
| 使用 FLOAT 存金额 | 使用 DECIMAL(10,2) | 浮点数精度问题 |

### 索引设计

| ❌ 错误做法 | ✅ 正确做法 | 原因 |
|------------|------------|------|
| 单列索引过多 | 设计组合索引 | 减少索引数量、提高效率 |
| 低区分度字段建索引（如性别） | 组合高区分度字段 | 索引效果差 |
| 索引列使用函数 | 直接对字段条件查询 | 索引失效 |
| 组合索引顺序随意 | 区分度高的列放前面 | 最左匹配原则 |

### SQL 编写

| ❌ 错误做法 | ✅ 正确做法 | 原因 |
|------------|------------|------|
| SELECT * FROM ... | SELECT 具体字段 | 网络开销、无法覆盖索引 |
| WHERE YEAR(create_time)=2024 | WHERE create_time >= '2024-01-01' | 函数导致索引失效 |
| OR 连接不同字段 | UNION ALL 分开查询 | OR 可能导致索引失效 |
| IN 子查询 | 改用 JOIN | IN 子查询性能差 |

### 事务处理

| ❌ 错误做法 | ✅ 正确做法 | 原因 |
|------------|------------|------|
| 大事务长时间持有锁 | 拆分小事务 | 锁等待、死锁风险 |
| 事务中包含 RPC 调用 | RPC 移到事务外 | 事务超时、锁持有时间长 |
| 不处理死锁 | 捕获死锁异常并重试 | 死锁是正常现象 |
| 使用 READ UNCOMMITTED | 使用 READ COMMITTED 或更高 | 脏读风险 |

---

## 验证清单 (Validation Checklist)

### 设计阶段

- [ ] 主键是否使用 BIGINT UNSIGNED AUTO_INCREMENT？
- [ ] 字段是否都定义了 NOT NULL 和默认值？
- [ ] 是否有适当的索引覆盖查询场景？
- [ ] 是否有 created_at 和 updated_at 字段？
- [ ] 字符集是否统一使用 utf8mb4？

### 开发阶段

- [ ] 是否避免了 SELECT *？
- [ ] WHERE 条件是否能命中索引？
- [ ] 是否避免了索引列上使用函数？
- [ ] 分页是否使用了游标分页（大偏移量时）？
- [ ] 批量操作是否控制了单次数量？

### 上线阶段

- [ ] 是否在测试环境验证了 SQL 性能？
- [ ] 是否检查了 EXPLAIN 执行计划？
- [ ] DDL 是否使用了 Online DDL？
- [ ] 是否配置了慢查询日志？

---

## 护栏约束 (Guardrails)

**允许 (✅)**：
- 使用 InnoDB 存储引擎
- 使用 utf8mb4 字符集
- 使用参数化查询防止 SQL 注入
- 使用连接池管理连接

**禁止 (❌)**：
- NEVER 使用 SELECT *
- NEVER 在索引列上使用函数或运算
- NEVER 使用 LIKE '%xxx' 前缀模糊查询
- NEVER 单次查询超过 1000 条不分页
- NEVER 在事务中进行 RPC 调用

**需澄清 (⚠️)**：
- 隔离级别：[NEEDS CLARIFICATION: READ COMMITTED/REPEATABLE READ?]
- 分表策略：[NEEDS CLARIFICATION: 按时间/按ID?]
- 读写分离：[NEEDS CLARIFICATION: 是否需要?]

---

## 常见问题诊断

| 症状 | 可能原因 | 解决方案 |
|------|----------|----------|
| 查询慢 | 缺少索引、索引失效 | EXPLAIN 分析、添加索引 |
| 锁等待超时 | 大事务、死锁 | 拆分事务、优化 SQL |
| 连接数过多 | 连接泄漏、未使用连接池 | 使用连接池、设置超时 |
| CPU 高 | 复杂查询、排序 | 优化 SQL、添加索引 |
| 磁盘 IO 高 | 全表扫描、大事务 | 添加索引、减小事务 |
| 主从延迟 | 大事务、大批量写入 | 拆分事务、错峰写入 |

---

## 索引设计原则

```
设计索引时，MUST 遵循：
1. 最左匹配：组合索引按最左前缀匹配
2. 区分度优先：高区分度字段放前面
3. 覆盖索引：尽量让查询只访问索引
4. 范围列最后：范围查询列放组合索引最后
5. 控制数量：单表索引不超过 5 个
```

---

## 输出格式要求

当生成数据库设计时，MUST 遵循以下结构：

```
## 设计说明
- 业务场景：[场景描述]
- 数据量预估：[预估数据量]
- 主要查询：[核心查询场景]

## 表结构
- 表名：[表名及说明]
- 字段列表：[字段、类型、说明]
- 索引设计：[索引名、字段、用途]

## 注意事项
- [设计约束和边界情况]
```
