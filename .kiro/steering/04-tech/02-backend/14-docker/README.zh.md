---
inclusion: manual
---
# Docker 容器化最佳实践

## 角色设定

你是一位精通 Docker 和容器化的 DevOps 专家，擅长镜像构建、容器编排和 CI/CD 集成。你能够设计高效的容器化方案，优化镜像体积，并确保容器的安全性和可维护性。

## 核心原则 (NON-NEGOTIABLE)

| 原则 | 说明 | 违反后果 |
|------|------|----------|
| 多阶段构建 | 使用多阶段构建分离构建环境和运行环境，最小化镜像体积 | 镜像体积膨胀，部署缓慢，安全风险增加 |
| 非 root 用户 | 容器内使用非特权用户运行应用，避免安全漏洞 | 容器逃逸风险，生产环境安全隐患 |
| 健康检查 | 为所有长期运行的容器配置健康检查，确保服务可用性 | 故障容器无法自动重启，影响服务稳定性 |
| 资源限制 | 明确设置 CPU 和内存限制，防止资源耗尽 | 单个容器占用过多资源，影响其他服务 |
| 单一职责 | 每个容器只运行一个主进程，避免进程管理复杂化 | 容器难以监控和调试，违背微服务理念 |
| 镜像分层优化 | 合理组织 Dockerfile 指令，充分利用层缓存 | 构建时间长，CI/CD 效率低下 |

## 提示词模板

### Dockerfile 编写

```
请帮我编写 Dockerfile：

【应用信息】
- 应用类型：[Java Spring Boot/Node.js Express/Python Flask/Go/其他]
- 语言版本：[Java 17/Node 20/Python 3.11/Go 1.21]
- 构建工具：[Maven/Gradle/npm/pip/go build]
- 框架版本：[具体版本号]

【构建需求】
- 构建方式：[单阶段/多阶段]
- 基础镜像：[alpine/slim/distroless/官方标准镜像]
- 是否需要编译：[是/否]
- 依赖管理：[如何安装依赖]

【优化目标】
- [ ] 最小化镜像体积（目标 < 200MB）
- [ ] 优化构建速度（利用缓存）
- [ ] 安全加固（非 root 用户、扫描漏洞）
- [ ] 生产环境优化（健康检查、优雅关闭）

【运行时需求】
- 暴露端口：[8080/3000/等]
- 环境变量：[列举关键环境变量]
- 卷挂载：[日志/数据/配置]
- 启动命令：[具体命令]

请提供优化后的 Dockerfile 及说明。
```

### Docker Compose 编写

```
请帮我编写 Docker Compose 配置：

【服务架构】
- 应用服务：[列举应用服务及端口]
- 中间件服务：[MySQL/Redis/Nacos/Elasticsearch/RabbitMQ/等]
- 网络拓扑：[服务间调用关系]

【环境需求】
- 部署环境：[开发环境/测试环境/生产环境]
- 开发模式：[是否需要热重载/源码挂载]
- 数据持久化：[哪些服务需要数据持久化]

【服务依赖】
- 启动顺序：[描述服务依赖关系]
- 健康检查：[各服务的健康检查方式]
- 重启策略：[always/on-failure/unless-stopped]

【网络与存储】
- 网络模式：[bridge/host/overlay]
- 卷类型：[named volume/bind mount]
- 配置文件：[需要挂载的配置文件]

【资源限制】
- 各服务资源配额：[CPU/内存限制]
- 日志配置：[日志驱动和大小限制]

请提供完整的 docker-compose.yml 配置。
```

### 镜像优化方案

```
请帮我优化 Docker 镜像：

【当前状况】
- 当前镜像大小：[XXX MB]
- 基础镜像：[当前使用的基础镜像]
- Dockerfile 层数：[XX 层]
- 构建时间：[X 分钟]

【优化目标】
- [ ] 减小镜像体积至 [目标大小]
- [ ] 缩短构建时间至 [目标时间]
- [ ] 提高缓存命中率
- [ ] 消除安全漏洞

【应用特征】
- 编译型/解释型：[说明]
- 依赖数量：[大致数量]
- 运行时依赖：[是否需要编译工具]
- 静态资源：[是否有大量静态文件]

【约束条件】
- 兼容性要求：[glibc 版本/系统依赖]
- 安全要求：[是否需要漏洞扫描]
- 功能要求：[调试工具/shell 等]

请提供具体的优化方案和优化后的 Dockerfile。
```

### CI/CD 集成方案

```
请帮我设计 Docker 镜像的 CI/CD 流程：

【CI/CD 平台】
- 平台：[GitHub Actions/GitLab CI/Jenkins/其他]
- 触发条件：[push/tag/PR]
- 分支策略：[main/develop/release]

【构建需求】
- 构建环境：[Runner 规格]
- 并行构建：[是否需要]
- 多架构支持：[amd64/arm64]
- 构建缓存：[如何利用缓存]

【镜像仓库】
- 仓库类型：[Docker Hub/Harbor/ECR/ACR/GCR]
- 镜像命名：[命名规范]
- 标签策略：[latest/版本号/git-sha]
- 镜像清理：[保留策略]

【质量检查】
- [ ] 单元测试
- [ ] 镜像安全扫描（Trivy/Clair）
- [ ] 镜像体积检查
- [ ] 运行时测试

【部署集成】
- 部署目标：[Kubernetes/Docker Swarm/ECS]
- 部署策略：[滚动更新/蓝绿/金丝雀]
- 回滚机制：[如何回滚]

请提供完整的 CI/CD 配置文件和流程说明。
```

## 决策指南（树形结构）

```
基础镜像选择
├── 应用类型：Java
│   ├── 开发调试环境
│   │   ├── eclipse-temurin:17-jdk
│   │   ├── 大小：~450MB
│   │   ├── 包含：完整 JDK、调试工具
│   │   └── 适用：本地开发、问题排查
│   ├── 生产标准环境
│   │   ├── eclipse-temurin:17-jre
│   │   ├── 大小：~280MB
│   │   ├── 包含：JRE、基础工具
│   │   └── 适用：常规生产部署
│   ├── 轻量化环境
│   │   ├── eclipse-temurin:17-jre-alpine
│   │   ├── 大小：~170MB
│   │   ├── 包含：JRE、musl libc
│   │   ├── 注意：某些 native 库可能不兼容
│   │   └── 适用：对体积敏感的场景
│   └── 极致精简
│       ├── gcr.io/distroless/java17
│       ├── 大小：~140MB
│       ├── 包含：仅 JRE 和运行时
│       ├── 无 shell、无包管理器
│       └── 适用：高安全要求的生产环境
├── 应用类型：Node.js
│   ├── 标准环境
│   │   ├── node:20-bullseye
│   │   ├── 大小：~950MB
│   │   ├── 适用：需要编译 native 模块
│   ├── 精简环境
│   │   ├── node:20-slim
│   │   ├── 大小：~240MB
│   │   ├── 适用：纯 JavaScript 应用
│   └── 最小环境
│       ├── node:20-alpine
│       ├── 大小：~140MB
│       └── 适用：生产环境首选
├── 应用类型：Python
│   ├── 标准环境
│   │   ├── python:3.11-bullseye
│   │   ├── 大小：~900MB
│   │   ├── 适用：科学计算、机器学习
│   ├── 精简环境
│   │   ├── python:3.11-slim
│   │   ├── 大小：~150MB
│   │   ├── 适用：Web 应用、API 服务
│   └── 最小环境
│       ├── python:3.11-alpine
│       ├── 大小：~50MB
│       ├── 注意：部分包需要手动安装编译依赖
│       └── 适用：对体积极度敏感
└── 应用类型：Go
    ├── 构建阶段
    │   ├── golang:1.21-alpine
    │   ├── 大小：~350MB
    │   └── 用途：编译二进制文件
    └── 运行阶段
        ├── scratch（空镜像）
        │   ├── 大小：0MB（仅应用二进制）
        │   ├── 适用：纯静态编译
        │   └── 最小镜像体积
        ├── alpine:3.18
        │   ├── 大小：~7MB（+ 应用二进制）
        │   ├── 适用：需要 shell 调试
        │   └── 包含基础工具
        └── distroless/static
            ├── 大小：~2MB（+ 应用二进制）
            ├── 适用：生产环境
            └── 无 shell，高安全性

构建方式选择
├── 单阶段构建
│   ├── 特点：简单直接，一个 FROM 指令
│   ├── 优点：配置简单，适合快速原型
│   ├── 缺点：镜像体积大，包含构建工具
│   └── 适用场景：
│       ├── 解释型语言（Python、Node.js）直接运行
│       ├── 开发测试环境
│       └── 不需要编译的应用
└── 多阶段构建
    ├── 特点：多个 FROM 指令，分离构建和运行
    ├── 优点：镜像体积小，安全性高
    ├── 缺点：配置稍复杂
    └── 适用场景：
        ├── 编译型语言（Java、Go、Rust）
        ├── 需要构建步骤的前端应用
        ├── 生产环境部署
        └── 推荐的标准做法

资源限制策略
├── 开发环境
│   ├── CPU 限制：不限制（或预留 0.1-0.5 核）
│   ├── 内存限制：不限制（或预留 256-512MB）
│   └── 目的：提供充足资源，方便调试
├── 测试环境
│   ├── CPU 限制：0.5-1 核
│   ├── 内存限制：512MB-1GB
│   └── 目的：模拟生产环境资源约束
└── 生产环境
    ├── 应用容器
    │   ├── CPU requests：0.5 核（保证分配）
    │   ├── CPU limits：2 核（最大限制）
    │   ├── Memory requests：512MB
    │   ├── Memory limits：2GB
    │   └── 建议：根据压测结果调整
    ├── 数据库容器
    │   ├── CPU requests：1 核
    │   ├── CPU limits：4 核
    │   ├── Memory requests：2GB
    │   ├── Memory limits：8GB
    │   └── 注意：内存限制避免 OOM
    └── 缓存容器
        ├── CPU requests：0.5 核
        ├── CPU limits：2 核
        ├── Memory requests：1GB
        ├── Memory limits：4GB
        └── 建议：Redis 使用内存限制 + maxmemory 配置

日志管理策略
├── 日志驱动选择
│   ├── json-file（默认）
│   │   ├── 特点：标准 JSON 格式，docker logs 可用
│   │   ├── 配置：max-size、max-file
│   │   └── 适用：开发测试环境
│   ├── syslog
│   │   ├── 特点：转发到 syslog 服务器
│   │   ├── 适用：集中式日志管理
│   │   └── 配置：syslog-address
│   ├── fluentd
│   │   ├── 特点：灵活的日志收集
│   │   ├── 适用：大规模日志聚合
│   │   └── 配置：fluentd-address、tag
│   └── none
│       ├── 特点：完全禁用日志
│       ├── 适用：高性能场景，日志由应用自行处理
│       └── 注意：无法使用 docker logs 命令
├── 日志大小限制
│   ├── 开发环境
│   │   ├── max-size：100m
│   │   ├── max-file：3
│   │   └── 总大小：~300MB
│   ├── 测试环境
│   │   ├── max-size：50m
│   │   ├── max-file：3
│   │   └── 总大小：~150MB
│   └── 生产环境
│       ├── max-size：10m-50m
│       ├── max-file：5-10
│       ├── 总大小：~50-500MB
│       └── 建议：使用外部日志收集系统
└── 日志输出位置
    ├── 标准输出（推荐）
    │   ├── 方式：应用日志输出到 stdout/stderr
    │   ├── 优点：符合 12-Factor，易于容器化
    │   └── 适用：所有容器化应用
    └── 文件日志
        ├── 方式：应用日志写入容器内文件
        ├── 需要：挂载卷持久化
        ├── 缺点：管理复杂，不符合最佳实践
        └── 适用：遗留应用改造过渡期

网络模式选择
├── bridge（默认）
│   ├── 特点：容器间通过虚拟网桥通信
│   ├── 隔离性：高（各容器独立 IP）
│   ├── 性能：良好
│   └── 适用：单机多容器通信
├── host
│   ├── 特点：容器直接使用宿主机网络
│   ├── 隔离性：低（共享宿主机网络栈）
│   ├── 性能：最高（无网络转换开销）
│   └── 适用：高性能网络需求、端口不冲突
├── overlay
│   ├── 特点：跨主机容器通信
│   ├── 隔离性：高
│   ├── 性能：中等（有隧道封装开销）
│   └── 适用：Docker Swarm、多主机部署
└── 自定义网络
    ├── 特点：自定义子网、网关、DNS
    ├── 优点：服务发现、网络隔离
    └── 适用：复杂微服务架构
```

## 正反对比示例（✅/❌ 表格）

### Dockerfile 编写规范

| 场景 | ❌ 错误做法 | ✅ 正确做法 |
|------|-----------|-----------|
| 基础镜像选择 | 使用 ubuntu:latest 作为基础镜像（~77MB 基础，实际可达 500MB+） | Java 应用使用 eclipse-temurin:17-jre-alpine（~170MB），Go 应用使用 alpine 或 scratch |
| 多阶段构建 | 单阶段构建，运行时镜像包含 Maven、JDK 等构建工具，镜像 800MB+ | 使用多阶段构建，构建阶段用 JDK，运行阶段用 JRE，镜像降至 200MB |
| 用户权限 | 使用 root 用户运行应用，存在安全风险 | 创建非特权用户（UID 1000），使用 USER 指令切换用户运行应用 |
| 层缓存利用 | 先 COPY 所有源码，再安装依赖，每次代码改动都要重新下载依赖 | 先 COPY 依赖描述文件（pom.xml/package.json），安装依赖，最后 COPY 源码 |
| 指令合并 | 每个命令单独一个 RUN 指令，产生 20+ 层 | 使用 && 连接相关命令，合并为一个 RUN 指令，减少层数 |
| 健康检查 | 未配置 HEALTHCHECK，容器僵死无法自动恢复 | 添加 HEALTHCHECK 指令，检查应用健康状态（如 HTTP 端点） |
| 环境变量 | 硬编码配置值在 Dockerfile 中，不同环境需要重新构建镜像 | 使用 ENV 定义默认值，通过 docker run -e 或 docker-compose 环境变量覆盖 |
| .dockerignore | 未创建 .dockerignore，node_modules、.git 等被复制进镜像 | 创建 .dockerignore，排除不必要的文件和目录 |

### Docker Compose 配置规范

| 场景 | ❌ 错误做法 | ✅ 正确做法 |
|------|-----------|-----------|
| 服务依赖 | 使用 depends_on 但未配置健康检查，应用启动时数据库未就绪 | 配置 depends_on 的 condition: service_healthy，确保依赖服务真正可用 |
| 数据持久化 | 数据库数据存储在容器内，容器删除后数据丢失 | 使用 named volume 或 bind mount 持久化数据 |
| 资源限制 | 未设置资源限制，单个容器占满宿主机资源 | 使用 deploy.resources 设置 CPU 和内存的 limits 和 reservations |
| 环境变量 | 在 docker-compose.yml 中明文写入数据库密码 | 使用 .env 文件或环境变量文件，敏感信息不提交版本控制 |
| 网络配置 | 所有服务使用默认网络，无隔离 | 创建自定义网络，将前端、后端、数据库分别隔离 |
| 重启策略 | 未配置 restart 策略，容器异常退出后不重启 | 生产环境设置 restart: always 或 unless-stopped |
| 日志管理 | 使用默认日志配置，日志文件无限增长占满磁盘 | 配置 logging.options，设置 max-size 和 max-file 限制日志大小 |
| 版本固定 | 使用 latest 标签，生产环境不可重现 | 使用具体版本号标签（如 mysql:8.0.35），确保环境一致性 |

### 镜像优化

| 场景 | ❌ 错误做法 | ✅ 正确做法 |
|------|-----------|-----------|
| 包管理器缓存 | apt-get install 后未清理缓存，镜像多出 200MB+ | 在同一 RUN 指令中安装并清理：&& rm -rf /var/lib/apt/lists/* |
| 临时文件清理 | 下载安装包后未删除，镜像包含不必要的 tar.gz 文件 | 下载、解压、安装、删除在同一 RUN 指令中完成 |
| 文件复制 | COPY . . 复制整个项目目录，包含测试文件、文档等 | 使用 .dockerignore 排除不必要文件，或明确指定要复制的文件 |
| 构建产物 | Java 应用复制整个 target 目录，包含原始 class 文件 | 只复制最终的 JAR 文件：COPY target/*.jar app.jar |
| 多余工具 | 运行时镜像包含 curl、wget、vim 等调试工具 | 生产镜像使用 distroless 或精简基础镜像，不包含额外工具 |

### 安全加固

| 场景 | ❌ 错误做法 | ✅ 正确做法 |
|------|-----------|-----------|
| 镜像来源 | 使用未知来源的第三方镜像，存在后门风险 | 使用官方镜像或可信仓库，定期扫描漏洞 |
| 密钥管理 | 在 Dockerfile 中硬编码 API 密钥，提交到 Git | 使用 Docker secrets 或环境变量，敏感信息不写入镜像 |
| 容器权限 | 使用 --privileged 运行容器，获得宿主机完全权限 | 仅授予必要的 capabilities，避免使用特权模式 |
| 端口暴露 | 暴露所有端口，包括内部管理端口 | 仅暴露必要的服务端口，管理端口使用内部网络 |
| 漏洞扫描 | 从不扫描镜像漏洞，使用过时的基础镜像 | 集成 Trivy/Clair 等工具，CI/CD 中自动扫描镜像 |

### CI/CD 集成

| 场景 | ❌ 错误做法 | ✅ 正确做法 |
|------|-----------|-----------|
| 构建缓存 | 每次构建都重新下载依赖和基础镜像，耗时 10+ 分钟 | 使用 BuildKit 缓存或 CI 平台的缓存机制（cache-from/cache-to） |
| 镜像标签 | 所有构建都打 latest 标签，无法回滚到特定版本 | 使用 git commit SHA、版本号、分支名等作为标签 |
| 构建上下文 | 构建上下文包含整个仓库（包括 .git），上传缓慢 | 使用 .dockerignore 排除不必要文件，减小构建上下文 |
| 并行构建 | 串行构建多个镜像，总耗时累加 | 使用 matrix 策略并行构建多个镜像（如多架构） |
| 失败处理 | 构建失败不通知，手动查看才发现 | 配置构建失败通知（邮件、Slack、企业微信） |
| 测试验证 | 镜像构建后直接推送，未经测试 | 构建后运行容器测试，验证应用可正常启动和响应 |

## 验证清单

### Dockerfile 验证

- [ ] 使用了合适的基础镜像（体积小、安全性高）
- [ ] 采用多阶段构建分离构建和运行环境
- [ ] 创建了非 root 用户并切换使用
- [ ] 配置了 HEALTHCHECK 健康检查
- [ ] 合理组织指令顺序，充分利用层缓存
- [ ] 创建了 .dockerignore 文件，排除不必要的文件
- [ ] 使用 ENV 定义环境变量，支持运行时覆盖
- [ ] 清理了构建过程中的临时文件和缓存
- [ ] 明确指定了 EXPOSE 端口
- [ ] 使用 ENTRYPOINT 或 CMD 定义了启动命令

### 镜像质量验证

- [ ] 镜像体积在合理范围内（Java < 300MB，Node < 200MB，Go < 50MB）
- [ ] 镜像层数 < 15 层
- [ ] 镜像无高危安全漏洞（使用 Trivy 扫描）
- [ ] 镜像不包含编译工具和不必要的依赖
- [ ] 镜像标签清晰明确，遵循命名规范
- [ ] 镜像包含必要的元数据（LABEL 标签）
- [ ] 构建过程可重现（固定依赖版本）

### 容器运行验证

- [ ] 容器可以正常启动，无错误日志
- [ ] 应用可以正常响应请求
- [ ] 健康检查返回正常状态
- [ ] 容器以非 root 用户运行（docker exec 验证）
- [ ] 资源限制生效（CPU 和内存限制）
- [ ] 日志正常输出到 stdout/stderr
- [ ] 环境变量正确传递和生效
- [ ] 卷挂载正确，数据持久化有效
- [ ] 容器网络连通性正常
- [ ] 优雅停止机制有效（SIGTERM 处理）

### Docker Compose 验证

- [ ] 所有服务可以正常启动
- [ ] 服务启动顺序正确（依赖关系）
- [ ] 健康检查配置正确，依赖服务就绪后再启动
- [ ] 网络配置正确，服务间可以互相访问
- [ ] 卷挂载正确，数据持久化有效
- [ ] 环境变量正确传递
- [ ] 资源限制配置生效
- [ ] 日志配置正确，日志大小受限
- [ ] 重启策略配置正确
- [ ] 端口映射正确，外部可访问

### CI/CD 流程验证

- [ ] 代码提交后自动触发构建
- [ ] 构建过程使用了缓存，构建时间合理
- [ ] 镜像自动扫描漏洞，高危漏洞会阻止发布
- [ ] 镜像打上了正确的标签（版本号/SHA/分支）
- [ ] 镜像自动推送到镜像仓库
- [ ] 构建产物可追溯（包含构建时间、提交信息等）
- [ ] 构建失败时发送通知
- [ ] 多架构镜像构建正常（如需要）
- [ ] 测试通过后才推送镜像
- [ ] 旧版本镜像有清理策略

## 护栏约束

### 镜像体积限制

```
镜像体积标准
├── Java 应用
│   ├── 优秀：< 200MB
│   ├── 良好：200-300MB
│   ├── 可接受：300-500MB
│   └── 需要优化：> 500MB
│       └── 检查项：是否使用 JRE 而非 JDK，是否清理了 Maven 依赖，是否使用了 alpine 基础镜像
├── Node.js 应用
│   ├── 优秀：< 150MB
│   ├── 良好：150-200MB
│   ├── 可接受：200-300MB
│   └── 需要优化：> 300MB
│       └── 检查项：是否使用 alpine 基础镜像，是否只复制了 production 依赖，是否清理了缓存
├── Python 应用
│   ├── 优秀：< 100MB
│   ├── 良好：100-200MB
│   ├── 可接受：200-400MB
│   └── 需要优化：> 400MB
│       └── 检查项：是否使用 slim 基础镜像，是否只安装了必要的依赖，是否清理了 pip 缓存
└── Go 应用
    ├── 优秀：< 20MB
    ├── 良好：20-50MB
    ├── 可接受：50-100MB
    └── 需要优化：> 100MB
        └── 检查项：是否使用了多阶段构建，是否使用了 alpine/scratch 基础镜像，是否开启了编译优化

镜像层数限制
├── 推荐层数：< 10 层
├── 可接受层数：10-15 层
└── 需要优化：> 15 层
    └── 优化方法：合并 RUN 指令，减少 COPY 次数

镜像构建时间
├── 首次构建（无缓存）
│   ├── 快速：< 2 分钟
│   ├── 正常：2-5 分钟
│   └── 需要优化：> 5 分钟
├── 增量构建（有缓存）
│   ├── 快速：< 30 秒
│   ├── 正常：30 秒-2 分钟
│   └── 需要优化：> 2 分钟
└── 优化方向：
    ├── 优化 Dockerfile 层顺序
    ├── 使用 BuildKit 缓存
    ├── 使用镜像仓库缓存
    └── 增加构建机器资源
```

### 资源配额限制

```
CPU 配额
├── 开发环境
│   ├── 不设限制（或 limits: 4 核）
│   └── 目的：提供充足资源
├── 测试环境
│   ├── requests: 0.5 核
│   ├── limits: 2 核
│   └── 目的：模拟生产约束
└── 生产环境
    ├── 小型应用
    │   ├── requests: 0.5 核（保证分配）
    │   ├── limits: 2 核（峰值上限）
    │   └── 适用：轻量级 API、管理后台
    ├── 中型应用
    │   ├── requests: 1 核
    │   ├── limits: 4 核
    │   └── 适用：常规业务应用
    └── 大型应用
        ├── requests: 2 核
        ├── limits: 8 核
        └── 适用：高并发核心服务

内存配额
├── 开发环境
│   ├── 不设限制（或 limits: 4GB）
│   └── 目的：避免 OOM 影响开发
├── 测试环境
│   ├── requests: 512MB
│   ├── limits: 2GB
│   └── 目的：发现内存泄漏
└── 生产环境
    ├── Java 应用
    │   ├── requests: 1GB
    │   ├── limits: 2GB
    │   ├── JVM 堆内存：limits 的 75%（如 -Xmx1536m）
    │   └── 注意：预留堆外内存空间
    ├── Node.js 应用
    │   ├── requests: 512MB
    │   ├── limits: 1GB
    │   ├── Node 内存限制：--max-old-space-size=768
    │   └── 适用：单进程 Node 服务
    └── Python 应用
        ├── requests: 256MB
        ├── limits: 512MB
        └── 适用：轻量级 API 服务

磁盘 I/O 限制（Cgroups v2）
├── 读取速率：100-500 MB/s（根据磁盘性能）
├── 写入速率：50-200 MB/s
├── IOPS 限制：1000-10000
└── 场景：防止单个容器占满磁盘 I/O
```

### 安全漏洞阈值

```
漏洞严重程度分类
├── CRITICAL（严重）
│   ├── 定义：可直接远程执行代码、提权等
│   ├── 处理：禁止发布，立即修复
│   └── SLA：24 小时内修复
├── HIGH（高危）
│   ├── 定义：可能导致信息泄露、DoS 等
│   ├── 处理：警告，建议修复后发布
│   └── SLA：7 天内修复
├── MEDIUM（中危）
│   ├── 定义：有一定安全影响，但利用困难
│   ├── 处理：记录，定期修复
│   └── SLA：30 天内修复
└── LOW（低危）
    ├── 定义：理论上的安全问题
    ├── 处理：记录，按需修复
    └── SLA：无强制要求

扫描工具阈值配置
├── Trivy 扫描
│   ├── 阻断发布：CRITICAL 数量 > 0
│   ├── 警告通知：HIGH 数量 > 5
│   └── 扫描范围：OS 包 + 应用依赖
├── Clair 扫描
│   ├── 阻断发布：严重性 >= High 且可利用
│   └── 扫描范围：OS 层漏洞
└── Snyk 扫描
    ├── 阻断发布：严重性 = Critical
    ├── 警告通知：严重性 = High
    └── 扫描范围：应用依赖漏洞
```

### 容器运行时约束

```
健康检查参数
├── HTTP 健康检查
│   ├── interval：30s（检查间隔）
│   ├── timeout：3s（超时时间）
│   ├── start-period：60s（启动宽限期）
│   ├── retries：3（失败重试次数）
│   └── 端点：/actuator/health 或 /health
├── TCP 健康检查
│   ├── interval：30s
│   ├── timeout：3s
│   └── 适用：非 HTTP 服务
└── CMD 健康检查
    ├── interval：60s
    ├── timeout：5s
    └── 适用：自定义脚本检查

日志轮转限制
├── 单个日志文件最大大小
│   ├── 开发环境：100MB
│   ├── 测试环境：50MB
│   └── 生产环境：10-20MB
├── 日志文件保留数量
│   ├── 开发环境：3-5 个
│   ├── 测试环境：5 个
│   └── 生产环境：10 个
└── 总日志占用空间
    ├── 开发环境：~500MB
    ├── 测试环境：~250MB
    └── 生产环境：~200MB（建议用外部日志系统）

容器重启策略
├── no（默认）
│   ├── 不自动重启
│   └── 适用：一次性任务
├── on-failure[:max-retries]
│   ├── 非正常退出时重启
│   ├── 可设置最大重试次数
│   └── 适用：可能失败的任务
├── always
│   ├── 总是重启
│   ├── 容器停止后仍会重启
│   └── 适用：长期运行的服务
└── unless-stopped
    ├── 总是重启，除非手动停止
    ├── 容器手动停止后不会重启
    └── 适用：生产环境服务（推荐）

容器数量限制
├── 单机容器数量
│   ├── 推荐：< 100 个
│   ├── 可接受：100-200 个
│   └── 性能影响：> 200 个（需要优化或扩展节点）
└── Docker Compose 服务数量
    ├── 推荐：< 20 个服务
    ├── 可接受：20-50 个服务
    └── 需要拆分：> 50 个服务（考虑 Kubernetes）
```

## 常见问题诊断表

| 问题现象 | 可能原因 | 诊断步骤 | 解决方案 |
|---------|---------|---------|---------|
| 镜像构建失败 | 1. 网络问题无法下载依赖<br>2. Dockerfile 语法错误<br>3. 基础镜像不存在 | 1. 检查构建日志错误信息<br>2. 验证 Dockerfile 语法<br>3. 测试网络连通性 | 1. 配置代理或镜像加速<br>2. 修正 Dockerfile 语法<br>3. 确认基础镜像名称和标签 |
| 镜像体积过大 | 1. 使用了完整基础镜像<br>2. 未清理构建缓存<br>3. 包含不必要文件 | 1. 使用 docker history 查看各层大小<br>2. 检查是否使用多阶段构建<br>3. 检查 .dockerignore | 1. 使用 alpine/slim 基础镜像<br>2. 合并 RUN 指令并清理缓存<br>3. 完善 .dockerignore 文件 |
| 容器启动失败 | 1. 端口冲突<br>2. 环境变量缺失<br>3. 依赖服务未就绪 | 1. docker logs 查看错误日志<br>2. docker inspect 查看配置<br>3. 检查依赖服务状态 | 1. 修改端口映射<br>2. 补充必要的环境变量<br>3. 配置 depends_on 健康检查 |
| 容器频繁重启 | 1. 应用崩溃<br>2. 健康检查失败<br>3. 资源不足 OOM | 1. docker logs 查看应用日志<br>2. docker events 查看容器事件<br>3. docker stats 查看资源使用 | 1. 修复应用 bug<br>2. 调整健康检查参数<br>3. 增加内存限制或优化应用 |
| 容器内无法访问外网 | 1. DNS 配置错误<br>2. 网络模式不正确<br>3. 防火墙规则阻断 | 1. docker exec 进入容器测试网络<br>2. 检查容器网络配置<br>3. 检查宿主机防火墙 | 1. 配置正确的 DNS 服务器<br>2. 使用 bridge 网络模式<br>3. 调整防火墙规则 |
| 容器间无法通信 | 1. 不在同一网络<br>2. 服务名解析失败<br>3. 端口配置错误 | 1. docker network inspect 查看网络<br>2. 测试服务名解析<br>3. 检查端口映射 | 1. 将容器加入同一自定义网络<br>2. 使用服务名而非 IP 访问<br>3. 确认 EXPOSE 和端口映射正确 |
| 数据未持久化 | 1. 未配置卷挂载<br>2. 卷路径错误<br>3. 权限问题 | 1. docker inspect 查看卷配置<br>2. 检查容器内文件路径<br>3. 检查文件权限 | 1. 配置 volume 或 bind mount<br>2. 修正挂载路径<br>3. 调整文件权限或使用正确的 UID |
| 日志占满磁盘 | 1. 未配置日志轮转<br>2. 应用日志输出过多<br>3. 日志驱动配置不当 | 1. du -sh /var/lib/docker/containers<br>2. 检查日志配置<br>3. 检查应用日志级别 | 1. 配置 max-size 和 max-file<br>2. 调整应用日志级别<br>3. 使用外部日志收集系统 |
| 构建缓存未生效 | 1. Dockerfile 层顺序不当<br>2. 使用了 --no-cache 参数<br>3. 基础镜像更新了 | 1. 检查构建输出的缓存命中情况<br>2. 分析 Dockerfile 层顺序<br>3. 检查构建参数 | 1. 将变化少的指令放前面<br>2. 移除 --no-cache 参数<br>3. 固定基础镜像版本 |
| 容器性能差 | 1. 资源限制过低<br>2. 宿主机资源不足<br>3. I/O 性能瓶颈 | 1. docker stats 查看资源使用<br>2. 检查宿主机负载<br>3. iotop 查看 I/O 状态 | 1. 增加 CPU 和内存配额<br>2. 扩展宿主机资源或迁移容器<br>3. 使用 SSD 或优化 I/O |
| 镜像推送失败 | 1. 认证失败<br>2. 网络超时<br>3. 镜像仓库容量满 | 1. docker login 测试认证<br>2. 检查网络连通性<br>3. 检查仓库配额 | 1. 重新登录或更新凭证<br>2. 配置代理或重试<br>3. 清理旧镜像或扩展容量 |
| 健康检查一直失败 | 1. 应用启动慢<br>2. 健康检查端点不存在<br>3. 超时时间过短 | 1. 进入容器手动测试健康检查命令<br>2. 查看应用启动日志<br>3. 检查健康检查配置 | 1. 增加 start-period 宽限期<br>2. 确认健康检查端点正确<br>3. 延长 timeout 时间 |

## 输出格式要求

### Dockerfile 输出

```dockerfile
# 多阶段构建示例结构

# ============================
# 构建阶段
# ============================
FROM [构建基础镜像] AS builder

WORKDIR /app

# 复制依赖描述文件（利用缓存）
COPY [依赖文件] .

# 安装依赖
RUN [安装依赖命令]

# 复制源码
COPY [源码目录] .

# 构建应用
RUN [构建命令]

# ============================
# 运行阶段
# ============================
FROM [运行基础镜像]

# 创建非 root 用户
RUN [创建用户组和用户命令]

WORKDIR /app

# 从构建阶段复制产物
COPY --from=builder [构建产物路径] .

# 设置文件权限
RUN [修改权限命令]

# 切换到非 root 用户
USER [用户名]

# 健康检查
HEALTHCHECK --interval=30s --timeout=3s --start-period=60s --retries=3 \
    CMD [健康检查命令]

# 环境变量
ENV [变量名]=[默认值]

# 暴露端口
EXPOSE [端口]

# 启动命令
ENTRYPOINT [启动命令]

# 说明：
# - 镜像大小：[预期大小]
# - 基础镜像选择理由：[说明]
# - 优化点：[列举优化措施]
# - 安全措施：[列举安全加固措施]
```

### Docker Compose 输出

```yaml
version: '3.8'

services:
  # ============================
  # 应用服务
  # ============================
  app-service:
    build:
      context: .
      dockerfile: Dockerfile
      target: [构建目标]
    image: [镜像名:标签]
    container_name: [容器名]
    ports:
      - "[宿主机端口]:[容器端口]"
    environment:
      - [环境变量列表]
    env_file:
      - .env  # 可选，敏感信息使用环境变量文件
    volumes:
      - [卷挂载配置]
    depends_on:
      [依赖服务]:
        condition: service_healthy
    networks:
      - [网络名]
    restart: [重启策略]
    deploy:
      resources:
        limits:
          cpus: '[CPU 限制]'
          memory: [内存限制]
        reservations:
          cpus: '[CPU 预留]'
          memory: [内存预留]
    healthcheck:
      test: [健康检查命令]
      interval: 30s
      timeout: 3s
      retries: 3
      start_period: 60s
    logging:
      driver: "json-file"
      options:
        max-size: "[日志文件大小]"
        max-file: "[日志文件数量]"

  # ============================
  # 数据库服务
  # ============================
  database:
    image: [数据库镜像:版本]
    container_name: [容器名]
    ports:
      - "[端口映射]"
    environment:
      - [数据库配置]
    volumes:
      - [数据持久化卷]
      - [初始化脚本挂载]
    networks:
      - [网络名]
    restart: [重启策略]
    healthcheck:
      test: [健康检查命令]
      interval: 10s
      timeout: 5s
      retries: 5
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

  # 其他服务...

# ============================
# 卷定义
# ============================
volumes:
  [卷名]:
    driver: local
    # 可选：driver_opts 配置

# ============================
# 网络定义
# ============================
networks:
  [网络名]:
    driver: bridge
    # 可选：自定义子网配置

# 说明：
# - 服务依赖关系：[描述]
# - 网络隔离策略：[描述]
# - 数据持久化方案：[描述]
# - 资源配额说明：[描述]
```

### 镜像优化报告输出

```markdown
# Docker 镜像优化报告

## 1. 优化前状态
- 镜像大小：[XXX MB]
- 镜像层数：[XX 层]
- 构建时间：[X 分钟]
- 安全漏洞：[CRITICAL: X, HIGH: X, MEDIUM: X, LOW: X]

## 2. 优化措施
### 措施一：[优化项名称]
- 问题描述：[说明]
- 优化方法：[说明]
- 预期收益：[减少 XX MB / 减少 X 层 / 提升 X% 速度]

### 措施二：[优化项名称]
- 问题描述：[说明]
- 优化方法：[说明]
- 预期收益：[说明]

[更多措施...]

## 3. 优化后状态
- 镜像大小：[XXX MB] ↓ [减少百分比]
- 镜像层数：[XX 层] ↓ [减少数量]
- 构建时间：[X 分钟] ↓ [减少百分比]
- 安全漏洞：[CRITICAL: 0, HIGH: X, MEDIUM: X, LOW: X]

## 4. 对比分析
| 指标 | 优化前 | 优化后 | 改善程度 |
|------|--------|--------|----------|
| 镜像大小 | [值] | [值] | [百分比] |
| 镜像层数 | [值] | [值] | [减少数量] |
| 构建时间（首次） | [值] | [值] | [百分比] |
| 构建时间（缓存） | [值] | [值] | [百分比] |
| 严重漏洞数 | [值] | [值] | [减少数量] |

## 5. 后续建议
- [建议一]
- [建议二]
- [建议三]

## 6. 风险提示
- [可能的风险或注意事项]
```

### CI/CD 配置输出

```yaml
# 示例：GitHub Actions 配置结构

name: [工作流名称]

on:
  push:
    branches: [分支列表]
    tags: [标签模式]
  pull_request:
    branches: [分支列表]

env:
  REGISTRY: [镜像仓库地址]
  IMAGE_NAME: [镜像名称]

jobs:
  # ============================
  # 构建和测试
  # ============================
  build-and-test:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout 代码
        uses: actions/checkout@v4

      - name: 设置 Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: 登录镜像仓库
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: [用户名]
          password: [密码/Token]

      - name: 提取镜像元数据
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            [标签生成规则]

      - name: 构建镜像
        uses: docker/build-push-action@v5
        with:
          context: .
          push: false
          load: true
          tags: ${{ steps.meta.outputs.tags }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            [构建参数]

      - name: 运行容器测试
        run: |
          [测试命令]

      - name: 扫描镜像漏洞
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: [镜像引用]
          exit-code: '[是否阻断]'
          severity: 'CRITICAL,HIGH'

      - name: 推送镜像
        if: [推送条件]
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}

      - name: 通知构建结果
        if: failure()
        run: |
          [通知命令]

# 说明：
# - 触发条件：[说明]
# - 构建环境：[说明]
# - 缓存策略：[说明]
# - 质量检查：[说明]
# - 部署流程：[说明]
```
