# 功能规格说明：MyBatis Plus 集成与节点管理仓储

**功能分支**: `001-mybatis-plus-integration`
**创建时间**: 2025-11-22
**状态**: 草稿
**输入**: 用户描述："doc/01-init-backend/2-mybatis-plus-integration.md - 集成 MyBatis Plus 并实现节点管理仓储"

## 澄清记录

### 会话 2025-11-22

- Q: 数据库连接池配置策略？ → A: 不同环境使用不同的连接池大小（local较小，prod较大）
- Q: 数据库表索引策略？ → A: name唯一索引，其他暂时不需要
- Q: Local环境数据库配置？ → A: 使用本地Docker环境中的MySQL数据库
- Q: Local环境数据库连接信息？ → A: 数据库名: aiops_local, 用户名: root, 密码: root123, 端口: 3306
- Q: 数据库连接池具体配置值？ → A: local(初始2/最小1/最大5), dev(初始5/最小3/最大10), test(初始5/最小3/最大10), staging(初始10/最小5/最大20), prod(初始20/最小10/最大50)
- Q: MyBatis-Plus SQL 日志打印级别？ → A: local/dev 使用 DEBUG，test/staging/prod 使用 WARN
- Q: MyBatis-Plus 分页插件合理性检查？ → A: 开启合理性检查（验证页码、页大小有效性）
- Q: Druid 监控功能？ → A: 所有环境都开启 Druid 监控（包括 StatViewServlet）
- Q: MyBatis-Plus SQL 格式化输出？ → A: 在 local 和 dev 环境启用 SQL 格式化（format-sql: true），便于调试
- Q: MyBatis-Plus 防止全表更新/删除插件？ → A: 启用 BlockAttackInnerInterceptor，防止误操作导致全表数据丢失

## 用户场景与测试 *(必填)*

### 用户故事 1 - 持久化和检索系统节点信息 (优先级: P1)

作为系统管理员，我需要将系统节点信息（数据库服务器、应用程序、API、报表）持久化到仓储中，以便在集中位置跟踪和管理所有系统组件。

**为什么是这个优先级**：这是支持所有其他节点管理操作的基础能力。如果没有保存和检索节点信息的能力，其他功能都无法运行。

**独立测试**：可以通过创建包含所有必填字段（名称、类型、描述、属性）的节点记录，并验证可以通过 ID 检索来完整测试。能够立即交付价值，实现基本的节点跟踪。

**验收场景**：

1. **给定** 系统正在运行，**当** 我保存一个新的数据库节点，名称为"MySQL-Primary"，类型为"DATABASE"，属性包含连接详情，**那么** 节点被持久化，包含自动生成的 ID、时间戳和默认值
2. **给定** 存在 ID 为 123 的节点，**当** 我通过 ID 检索该节点，**那么** 返回所有节点详情，包括名称、类型、描述、属性、时间戳和审计字段
3. **给定** 存在名称为"MySQL-Primary"的节点，**当** 我通过名称检索该节点，**那么** 返回节点信息，所有字段都正确填充

---

### 用户故事 2 - 按类型查询节点和分页 (优先级: P2)

作为系统管理员，我需要按类型（DATABASE、APPLICATION、API、REPORT、OTHER）查询节点并查看分页结果，以便高效浏览和管理特定类别的系统组件。

**为什么是这个优先级**：这在基本持久化能力的基础上增加了必要的查询功能。按类型过滤和分页对于高效管理大量节点至关重要。

**独立测试**：可以通过创建多个不同类型的节点，并验证可以按类型过滤并获得分页结果来完整测试。通过实现有组织的节点集合查看来交付价值。

**验收场景**：

1. **给定** 存在多个类型为"DATABASE"的节点，**当** 我按类型"DATABASE"查询，**那么** 返回所有数据库节点，按创建时间降序排列（最新的在前）
2. **给定** 总共存在 150 个节点，**当** 我请求第 2 页，每页 50 个节点，**那么** 我收到节点 51-100，总计数为 150，以及正确的分页元数据
3. **给定** 存在各种类型的节点，**当** 我查询第 1 页，过滤类型为"APPLICATION"且名称包含"order"，**那么** 只返回匹配名称过滤器的应用程序节点，并包含正确的分页信息

---

### 用户故事 3 - 更新节点信息 (优先级: P3)

作为系统管理员，我需要更新现有节点信息（描述、属性、类型），以便在系统配置发生变化时保持节点记录的准确性。

**为什么是这个优先级**：虽然对于维护数据准确性很重要，但这比基本的持久化和查询能力的优先级要低。如果时间紧张，更新功能可以延后实现。

**独立测试**：可以通过创建节点、修改其字段，并验证更改是否持久化，包括更新的时间戳和版本号来完整测试。通过实现节点信息维护来交付价值。

**验收场景**：

1. **给定** 存在版本为 0 的节点，**当** 我更新节点的描述和属性，**那么** 更改被保存，updateTime 被刷新，version 增加到 1，并记录 updateBy
2. **给定** 两个并发更新操作针对同一节点，**当** 两者都尝试保存更改，**那么** 第一个成功，第二个因乐观锁冲突而失败
3. **给定** 存在具有特定属性的节点，**当** 我只更新描述字段，**那么** 只有描述和审计字段发生变化，其他字段保持不变

---

### 用户故事 4 - 逻辑删除节点 (优先级: P3)

作为系统管理员，我需要在不物理删除数据的情况下逻辑删除节点，以便维护审计跟踪并可能恢复意外删除的节点。

**为什么是这个优先级**：逻辑删除对于数据完整性和可审计性很重要，但不是基本节点管理操作所必需的。可以在核心持久化功能之后实现。

**独立测试**：可以通过创建节点、删除它，并验证它不再出现在查询中但在数据库中保留删除标记来完整测试。通过提供安全的删除和回滚能力来交付价值。

**验收场景**：

1. **给定** 存在 ID 为 123 且 deleted = 0 的节点，**当** 我删除该节点，**那么** deleted 字段设置为 1，updateTime 和 updateBy 被更新
2. **给定** 节点已被逻辑删除，**当** 我通过 ID、名称或类型查询节点，**那么** 已删除的节点不会出现在任何查询结果中
3. **给定** 数据库中存在逻辑删除的节点，**当** 我直接查询数据库 deleted = 1 的记录，**那么** 节点记录仍然存在，包含所有原始数据

---

### 边界情况

- 当尝试创建具有重复名称的节点时会发生什么？系统必须拒绝操作并返回唯一约束违规错误
- 当尝试保存具有无效类型（不是 DATABASE、APPLICATION、API、REPORT、OTHER 之一）的节点时会发生什么？系统必须验证并拒绝，并返回适当的错误消息
- 当尝试更新自加载以来已被其他用户修改的节点时会发生什么？乐观锁版本检查必须使操作失败，以防止丢失更新
- 当尝试使用无效分页参数（负页码、页大小 > 100）查询时会发生什么？系统必须验证并拒绝，并返回适当的错误消息
- 当 properties 字段包含格式错误的 JSON 时会发生什么？系统必须验证 JSON 格式并拒绝无效输入
- 当尝试更新已逻辑删除的节点时会发生什么？系统应该阻止操作或根据业务规则处理
- 当保存操作期间数据库连接失败时会发生什么？系统必须传播适当的连接错误而不破坏数据

## 需求 *(必填)*

### 功能需求

- **FR-001**: 系统必须使用雪花算法自动生成唯一 ID 来持久化节点实体
- **FR-002**: 系统必须在插入和更新操作时自动填充 createTime 和 updateTime 时间戳
- **FR-003**: 系统必须通过接受 operator 参数来支持操作人跟踪，以填充 createBy 和 updateBy 字段
- **FR-004**: 系统必须对节点名称字段强制执行唯一约束，通过数据库唯一索引实现
- **FR-005**: 系统必须根据允许的值（DATABASE、APPLICATION、API、REPORT、OTHER）验证节点类型
- **FR-006**: 系统必须支持在 properties 字段中以 JSON 格式存储可扩展的节点属性
- **FR-007**: 系统必须使用 version 字段实现乐观锁，以防止并发更新冲突
- **FR-008**: 系统必须使用 deleted 字段实现逻辑删除（0 = 活动，1 = 已删除），而不是物理删除
- **FR-009**: 系统必须支持按 ID 查询，返回单个节点或未找到时返回 null
- **FR-010**: 系统必须支持按名称查询，返回单个节点或未找到时返回 null（排除逻辑删除的节点）
- **FR-011**: 系统必须支持按类型查询，返回匹配节点列表，按 createTime 降序排列（排除逻辑删除的节点）
- **FR-012**: 系统必须支持分页查询，可按名称（部分匹配）和类型（精确匹配）过滤
- **FR-013**: 系统必须将分页每页最大记录数限制为 100 条，并开启分页合理性检查验证页码和页大小的有效性
- **FR-014**: 系统必须从所有查询操作中排除逻辑删除的节点（deleted = 1）
- **FR-015**: 系统必须支持更新操作，自动递增版本号并更新 updateTime
- **FR-016**: 系统必须阻止全表更新和删除操作作为安全机制
- **FR-017**: 系统必须支持多环境配置（local、dev、test、staging、prod）的数据库连接，每个环境配置独立的连接池大小以优化资源使用
- **FR-018**: 系统必须使用参数化查询来防止 SQL 注入攻击
- **FR-019**: 系统必须在数据库操作之前验证所有输入参数（空值检查、长度限制、格式验证）
- **FR-020**: 系统必须在保存/更新操作后返回已保存/更新的节点实体，并填充生成的值（ID、时间戳、版本）

### 核心实体

- **NodeEntity（节点实体）**: 表示系统节点（数据库、应用程序、API、报表或其他系统组件）。关键属性包括：
  - **id（ID）**: 唯一标识符（Long 类型）
  - **name（名称）**: 节点名称，具有唯一约束，最大 100 个字符
  - **type（类型）**: 节点类别（DATABASE、APPLICATION、API、REPORT、OTHER）
  - **description（描述）**: 可选的文本描述，最大 500 个字符
  - **properties（属性）**: JSON 格式字符串，用于可扩展属性（连接信息、配置等）
  - **createTime（创建时间）**: 记录创建时间戳
  - **updateTime（更新时间）**: 最后修改时间戳
  - **createBy（创建人）**: 创建记录的用户
  - **updateBy（更新人）**: 最后修改记录的用户
  - **deleted（删除标记）**: 逻辑删除标志（0 = 活动，1 = 已删除）
  - **version（版本号）**: 乐观锁版本号

- **PageResult（分页结果）**: 通用分页容器，包含：
  - **current（当前页）**: 当前页码
  - **size（每页大小）**: 每页记录数
  - **total（总记录数）**: 匹配记录的总数
  - **pages（总页数）**: 总页数
  - **records（记录列表）**: 当前页的实体列表

## 成功标准 *(必填)*

### 可衡量的结果

- **SC-001**: 单条记录的节点保存操作在 100 毫秒内完成
- **SC-002**: 按 ID 查询节点在 50 毫秒内完成
- **SC-003**: 无论总记录数多少，分页查询在 200 毫秒内返回结果
- **SC-004**: 系统通过唯一约束 100% 成功阻止重复的节点名称
- **SC-005**: 乐观锁以 100% 的准确性防止并发更新冲突
- **SC-006**: 所有查询操作以 100% 的准确性正确排除逻辑删除的节点
- **SC-007**: 系统处理 100 个并发保存/更新操作而不发生数据损坏
- **SC-008**: 所有数据库操作使用参数化查询来防止 SQL 注入
- **SC-009**: 节点实体在所有五个环境（local、dev、test、staging、prod）中成功持久化，并具有适当的配置
- **SC-010**: 所有时间戳（createTime、updateTime）自动填充，无需手动干预
- **SC-011**: JSON 属性字段正确存储和检索复杂的嵌套 JSON 结构
- **SC-012**: 分页正确地将每页最大记录数限制为 100 条
- **SC-013**: 系统通过安全拦截器 100% 阻止全表更新/删除操作

### 假设

- 数据库表在应用程序启动之前创建（使用手动模式创建或迁移工具）
- 每个环境都有自己独立的数据库实例
- Local环境使用Docker容器中的MySQL数据库进行本地开发（数据库名: aiops_local, 用户名: root, 密码: root123, 端口: 3306, 主机: localhost）
- 部署期间将为所有五个环境提供数据库凭据
- 连接池配置按环境差异化，具体配置为：
  - local: 初始连接数2, 最小空闲1, 最大活跃5（适合本地开发调试）
  - dev: 初始连接数5, 最小空闲3, 最大活跃10（支持开发环境测试）
  - test: 初始连接数5, 最小空闲3, 最大活跃10（支持集成测试）
  - staging: 初始连接数10, 最小空闲5, 最大活跃20（接近生产配置）
  - prod: 初始连接数20, 最小空闲10, 最大活跃50（支持生产高并发）
- 数据库表初期只需在name字段创建唯一索引，其他字段（type、deleted、createTime）的索引根据实际性能需求后续添加
- 节点名称唯一性区分大小写
- properties 字段的 JSON 验证在应用层执行，而不是数据库层
- 操作人（createBy/updateBy）值由调用层（应用程序/服务）提供，而不是从安全上下文派生
- 逻辑删除的节点将无限期保留以用于审计目的（无自动清除）
- 数据库时区为 UTC 或在所有环境中一致配置
- MyBatis-Plus 版本 3.5.7 与 Spring Boot 3.4.1 和 Java 21 兼容
- 数据库字符集为 UTF8MB4，以支持完整的 Unicode，包括表情符号和特殊字符
- MyBatis-Plus SQL 日志级别按环境配置：local 和 dev 环境使用 DEBUG 级别（打印完整 SQL 便于调试），test、staging 和 prod 环境使用 WARN 级别（避免日志过多）
- MyBatis-Plus SQL 格式化输出配置：local 和 dev 环境启用 SQL 格式化（format-sql: true），使复杂 SQL 更易读便于调试；test、staging 和 prod 环境不启用以节省日志空间
- MyBatis-Plus 分页插件开启合理性检查，自动验证和修正不合法的分页参数（如负数页码、超大页码、超过 maxLimit 的页大小）
- MyBatis-Plus 防止全表更新/删除插件（BlockAttackInnerInterceptor）在所有环境启用，拦截没有 WHERE 条件的 UPDATE 和 DELETE 语句，防止误操作导致全表数据丢失
- Druid 数据库连接池在所有环境都开启监控功能，包括 StatViewServlet，便于监控连接池状态和 SQL 执行情况
